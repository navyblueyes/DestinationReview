<!-- Start Document Outline -->

* [Spring Boot Fundamentals - O'Reilly](#spring-boot-fundamentals---oreilly)
	* [Module 1: A Simple Spring Model-View-Controller (MVC) Application](#module-1-a-simple-spring-model-view-controller-mvc-application)
	* [Module 2: Using Spring to Access REST Services](#module-2-using-spring-to-access-rest-services)
	* [Module 3: Persistence Mechanisms](#module-3-persistence-mechanisms)

<!-- End Document Outline -->

# Spring Boot Fundamentals - O'Reilly



## Module 1: A Simple Spring Model-View-Controller (MVC) Application
### Course Introduction
- Spring
    - built on top of JDK
    - will compare template vs restful service
    - testing + functional testing

### The Role of Spring in Application Development
- Java EE
    - infrastructure that provided services on demand
    - To provide services....
        - had to utilize enterprise javabeans  
        - had to sport servers
            - both not efficient
- Spring
    - 
    - Open source
        - shared services like
            - transactions
            - services
            - resource pooling
    - declarative services
        - provided by `beans`
        - consist of services like...
            - auto wiring
            - dependency injection
    - lifecycle management
        - classes are generated by spring
            - maintained IN MEMORY
            - provide references
                - ... aka... dependency injections
    - ![](img/01002.jpg)
        - beans
            - POJO - plain old Java object
            - Java class with getters and setters
        - difference between Java EE and Spriing
            - declarative
                - similar services
                - ... but.... 
                    - do NOT need to acquire an instance and call it
                        - called programmatic service
                - instead of programmatic service...
                    - no instance... drop an annotation
                    - `@tran`saction` near your method 
    - ![](img/01001.jpg)
    - ![](img/01003.jpg)
        - to perform declarative functions...
            - must provide metadata
                - users change it with `JavaConfig` beans
                    - a way for users to define beans that Spring should be managing within application context
                - users can modify components with `Annotation` beans
                    - RESTcontrollers, repositories
    - ![](img/01004.jpg)
        - execution context where Spring loads beans
            - access the beans through `ApplicationContext`
    - ![](img/01005.jpg)
        - Purpose
            - create an easier way to create beans
            - easier auto configure a new Spring
        - Implementation
            - requires either maven or gradle
            - configure by filling out forms
            - auto-builds an initial web app with desired database drivers
        - easier configuration
            - take a class
            - serialize into json
            - spring boot will automatically get class to JSON 
    - ![](img/01006.jpg)
        - IDE / spring tools suite / VScode

### Creating a New Application
- ![](img/01007.jpg)
    - IMPORTANT -- Spring Boot Version
        - dictates what all dependencies look like
            - ie... correct Hibernate and JBDC versions
    - Java 11 - LTS for now
        - WAR packaging for serving webpages
        - JAR contains Tomcat for more flexibility with 
- ![](img/01008.jpg)
    - Dependencies - Spring Web
        - ThymeLeaf for templating
- ![](img/01009.jpg)
    - Generate compiles dependencies into a `demo.zip`
        - ![](img/01010.jpg)

### Importing into an Integrated Development Environment (IDE)
- ![](img/01011.jpg)
- ![](img/01012.jpg)
- SpringToolSuite
    - Getting the jar within
        - ![](img/01013.jpg)
        - ![](img/01014.jpg)
        - ![](img/01015.jpg)
    - Creating from scratch
        - ![](img/01016.jpg)
        - ![](img/01017.jpg)

### Adding a Controller
- Purpose
    - REST controller receives a request
        - returns a destination
- Creating a Controller
    - Create a class at File Location --- sec/main/java/nameOfApplication
        - ![](img/01018.jpg)
    -  Name the new class
        - ![](img/01019.jpg)
            - ![](img/01020.jpg)
    - Turn the class into a controller with `@Controller`
        - ![](img/01021.jpg)
            - ![](img/01022.jpg)
    - Highlight the annotation to ascertain what is injected
        - ![](img/01023.jpg)
            - Notice it is a `@Component`
    - Note that `@SpringBootApplication` within the main java is a `@ComponentScan`
        - ![](img/01024.jpg)
            - 
    - Creating a controller
        - `@GetMapping` to associate a class with a specific route
            - ![](img/01025.jpg)
        - create a public class that takes a `String` and a view model (`Model`)
            - ![](img/01044.jpg)
                - note the types
                    - `name` parameter is a `String` types
                    - `model` output is a template model types
        - modify the String parameter with `@RequestParam` to dictate required parameter `/hello?name=Mike`
            - ![](img/01026.jpg)
                - `value` dictates name of the parameter
                - `required` dictates requirement
                - `defaultValue` shows what the default value will be for parameter
        - `return` a template from the `src/main/resources/templates`
            - ![](img/01027.jpg)
        - add `name` to the view model with `model.addAttribute()`
            - ![](img/01028.jpg)
                - the viewmodel is `src/main/resources/templates/hello.html`
                    - ![](img/01029.jpg)

### Adding a View
- Implementing a view
    - Utilize ThymeLeaf with html
        - ![](img/01030.jpg)
- Running it 
    - ![](img/01032.jpg)
    - ![](img/01031.jpg)
    - ![](img/01033.jpg)
        - 
- Configuring Java with `application.properties`
    - modifying logging with `logging.level.web=debug`
        - ![](img/01035.jpg)
        - ![](img/01034.jpg)
        - ![](img/01036.jpg)

### Add an Index Page
- Add an index page (`index.html`)
    - ![](img/01037.jpg)
        - ![](img/01038.jpg)
    - ![](img/01039.jpg)
        - ![](img/01040.jpg)
- Outputting a Maven package
    - ![](img/01041.jpg)
        - ![](img/01042.jpg)
- Deploying the maven package
    - ![](img/01043.jpg)

### Testing Controllers Part I
- Writing a JUnit test to invoke Controller class
    - ![](img/01045.jpg)
        - JUnit turns `sayHello` into a `@Test`
        - `HelloController` is instantiated with `new HelloController()`
        - utilize view-model by `BindingAwareModelMap()`
            - Remember that `.sayHello` takes both a string and model
                - need to create the model
                    - ![](img/01046.jpg)
        - utilize `assertAll` JUnit method to invoke all methods
- Note
    - Mockito
        - mocks the interface to properly test all inputs

### Testing Controllers Part II
- Documentation Pattern
    - Read the `Spring` doc
        - Check if it is simplified within `Spring Boot`
- Reading Documentation for Mocking Websites
    - Looking for "mock" on the spring framework documentation
        - ![](img/01047.jpg)
    - Spring Documentation
        - ![](img/01048.jpg)
    - Spring Boot Documentation
        - ![](img/01049.jpg)
            - note that it 
                - auto-configures theMVC
                - looks for `@Controller` and NOT the `@Component`
            - example from the documentation
                - ![](img/01050.jpg)
- Implementation 
    - ![](img/01051.jpg)
        - `@WebMvcTest()` looks for the `HelloController.class` for the test
        - `@Autowired` tells Spring to check for `MockMvc` within `ApplicationContext`
            - to test if it worked
                - ![](img/01052.jpg)
- Actual Test
    - ![](img/01053.jpg)
        - Call the MockMvc instance with `mvc` and run the `.perform(get("/hello"))`
            - ensure the received is a HTML with `.accept(MediaType.TEXT_HTML)`
        - have mockMvc check the `status`, `view`, `model` with `.andExpect()`
        - in the second test... we insert a parameter with `mvc.paran("name","Dolly")`
    - Notice that `MockMvcRequesBuilders` handles all the REST verbs
        - ![](img/01054.jpg)
    - Run the test
        - ![](img/01055.jpg)
        - ![](img/01056.jpg)

### Creating a RESTful Web Service
- Modern day application
    - Generate JSON for device
    - Device receives JSON
- Serializing a Greeting into JSON
    - Greeting class
        - ![](img/01057.jpg)
    - `@RestController`
        - ![](img/01058.jpg)
    - create a `@RestController` class method of `greet`
        - ![](img/01059.jpg)
    - add mapping with `@GetMapping()`
        - ![](img/01060.jpg)
    - add request parameters with `@RequestParam`
        - ![](img/01061.jpg)
- Testing
    - ![](img/01062.jpg)
    - ![](img/01063.jpg)

### Testing RESTful Components
- Will be using `TestRestTemplate`
    - ![](img/01064.jpg)
        - 
- Running a test on REST Controller `HelloRestControllerFunctionalTest`
    - Utilize a `@SpringBootTest` to create a test server with random port number
        - ![](img/01065.jpg)
    - Run two `@Test`, be sure to `@Autowired` the TestRestTemplate
        - ![](img/01066.jpg)
    - utilize the `TestRestTemplate` to turn `Greeting` into a JSON
        - ![](img/01067.jpg)
    - the `.getForEntity` adds more data into the JSON... ie headers and status code, content type
        - ![](img/01069.jpg)
            - ![](img/01068.jpg)
            - notice we get the header, status code and content type
            - notice it is no longer a `response`... but a `ResponseEntity`


## Module 2: Using Spring to Access REST Services
* [Go to Module 3](#module-3-persistence-mechanisms)

### The Spring Application Context
- Application Context
    - auto wire your application context
        - ![](img/02002.jpg)
            - ![](img/02001.jpg)
    - see what is in the application context 
        - ![](img/02004.jpg)
    - see all the beans with `.getBeanDefinitionCount()`
        - ![](img/02005.jpg)
            - ![](img/02006.jpg)
        - ![](img/02007.jpg)
    - If you change the controllers name with `@Controller(newName)`
        - ![](img/02008.jpg)
    - `Greeting.java` is NOT used in any part of the `ApplicationContext`
        - therefore...
            - never loaded
        - if we put it in the test...
            - ![](img/02009.jpg)
        - to force `Greeting.java` to be used...
            - before...
                - ![](img/02010.jpg)
            - after...
                - ![](img/02011.jpg)
- NOTE
    - all objects within `ApplicationContext` are Singletons
        - ![](img/02012.jpg)
            - we thought we created two separate instances of `Greeting.class`
                - instead...
                    - `greeting2` is just a reference to `greeting1`
    - ONLY WAY AROUND THIS... prototype it to be a factory
        - with `@Scope`

### Adding Beans Using JavaConfig
- Avoid `ApplicationContext` manipulation by setting configs with `JavaConfig`
    - 
        - 
- `@SpringBootApplication` has a configuration
    - Taking a look at the docs...
        - ![](img/02013.jpg)
            - ![](img/02014.jpg)
    - Typical `@Configuration` setup
        - ![](img/02015.jpg)
            - annotate methods with an `@Bean` so that it would instantiates/configures that bean
    - Since `@SpringBootApplication` is a `@Configuration`...
        - ![](img/02016.jpg)
    - Testing it...
        - ![](img/02017.jpg)
- Moving the configurations to its own file
    - creating `AppConfig.java`
        - ![](img/02018.jpg)
    - Creating an alternate greeting
        - ![](img/02019.jpg)
            - ![](img/02020.jpg)
    - Fixing the `expected single bean` error
        - ![](img/02021.jpg)
            - ![](img/02022.jpg)

### Spring's RestTemplate Class
- Intro
    - Will run an API through RestTemplate
        - the API source
            - ![](img/02023.jpg)
            - ![](img/02024.jpg)
            - ![](img/02025.jpg)
                - Note the `people: [ { "name": "asdf", "craft":"asdf" }, ...` format
- Writing the API Fetcher
    - Organizing JSON into Java
        - Writing a POJO for the inbound data
            - Setting up the data structure
                - ![](img/02026.jpg)
            - Establishing getters / setters
                - ![](img/02027.jpg)
        - Writing a POJO for the outbound data
            - Data Structure
                - ![](img/02030.jpg)
            - Establishing getters / setters
                - ![](img/02031.jpg)
    - Creating a template
        - templates are created using `RestTemplateBuilder`
            - doc...
                - ![](img/02028.jpg)
            - implementation
                - create a `RestTemplateBuilder` instance; call `.build()` method; insert into `template`
                    - ![](img/02032.jpg)
                - note the different methods that could be invoked
                    - ![](img/02033.jpg)
    - Calling API
        - utilize the `.getForObject()` from the URL; put it into `AstroResult` data structure
            - ![](img/02034.jpg)
    - Create a service bean
        - What is a service
            - ![](img/02029.jpg)
        - Implementation
            - ![](img/02035.jpg)
- Testing the API Fetcher
    - Wire it to the API service bean
        - ![](img/02036.jpg)
    - Call the test method
        - ![](img/02037.jpg)
    - Within test method, call the service and store it
        - ![](img/02038.jpg)
    - Within test method, print out the numbers
        - ![](img/02039.jpg)
            - notice we are utilizing the `.getNumber()` getter
    - Within test method, print out all the people
        - ![](img/02040.jpg)
    - Assert to check the results
        - ![](img/02041.jpg)

### Using the Reactive WebClient Class
- Intro
    - Reactive WebClient
        - the modern version of `RestTemplate`
    - What is it...
        - ![](img/02042.jpg)
            - an error won't stop the `ApplicationContext`
            - an infinite wait won't slow down the application
- `WebClient.ResponseSpec` `retrieve()`
    - the docs...
        - ![](img/02043.jpg)
            - `.get()` acts like a GET html action
            - `.uri("")` dictates route that calls get function
            - `.accept()` dictates the anticipated file format
            - `.retrieve()` executes get action
            - `.bodyToMono()` converts JSON into Java class; name of java class is specified within `()`
    - implementation
        - instantiate a `WebClient`
            - ![](img/02044.jpg)
        - wire the `WebClient.Builder` and build it on the API address
            - ![](img/02045.jpg)
        - run the `retrieve()` library onto the `client`
            - ![](img/02046.jpg)
    - testing
        - mostly the same; ensure to call the proper function
            - ![](img/02047.jpg)

### Accessing the Google Geocoder
- What is Geocoding
    - Google definition
        - ![](img/03001.jpg)
    - Two Required Parameters to be aware
        - ![](img/03002.jpg)
        - ![](img/03003.jpg)
    - Response
        - ![](img/03004.jpg)
            - ![](img/03005.jpg)
                - Note the `lat` `lng`
- Fitting Geocoding into Java
    - Lat / Lng Java Class
        - ![](img/03006.jpg)
    - Geometry Class
        - ![](img/03007.jpg)
    - Result Class (takes Geometry and returns LatLng)
        - ![](img/03008.jpg)
    - Response Class (takes multiple results)
        - ![](img/03009.jpg)
    - Site Class 
        - ![](img/03017.jpg)
- Creating a Geocoder Service
    - Creating a `@Service` bean
        - ![](img/03010.jpg)
    - `@Autowired` the `WebClient.Builder`
        - ![](img/03011.jpg)
    - Create a method to retrieve the geocode json and 
        - `.collect()` the `Stream` of the input `address` in the `encoded`
            - ![](img/03015.jpg)
        - send the `encoded` in a `.retrieve()` request
            - ![](img/03016.jpg)
                - store the results within the `Response` format
    - getting the results we want...
        - to get the addresses...
            - run `Result`'s `getFormattedAddress()` on the response first
                - ![](img/03014.jpg)
        - to get the lat / longd
            - run `Geometry`'s `getLocation()`
                - ![](img/03012.jpg)
            - run `Location`'s `.getLat()` / `.getLng()`
                - ![](img/03013.jpg)
- Testing the service
    - Writing the test
        - the first test (merely name of a city)
            - ![](img/03018.jpg)
        - the second test (actual address)
            - ![](img/03019.jpg)
        - notice we call the logger AFTER EVER `site` call
            - ![](img/03020.jpg)
    - Results
        - HTTP GET request sent
            - ![](img/03021.jpg)
        - Lat / Long3
            - ![](img/03022.jpg)
        - fixing the `address: null`
            - difference in the documentation
                - ![](img/03023.jpg)
                - ![](img/03024.jpg)
            - check the config.... (`application.properties`)
                - ![](img/03025.jpg)
        - getting the results
            - ![](img/03026.jpg)


## Module 3: Persistence Mechanisms

### The JdbcTemplate Class
- Why `JdbcTemplate`?
    - want to pass SQL to database
        - NOT want to convert rows into objects
        - NOT want to convert objects into rows
- Documentation
    - ![](img/03027.jpg)
    - ![](img/03028.jpg)
        - Note that Jdbc will classify SQL exceptions as Data Access exceptions (3:25)
    - ![](img/03029.jpg)
- Query (4:17)
    - `.queryForObject()`
        - sends a SQL query and returns a class object
            - NOTE ---> throws error IF NOT RETURN EXACTLY ONE ROW
                - ![](img/03060.jpg)
    - SQL statement and the return class
        - ![](img/03030.jpg)
            - `.queryForObject()`
                - first argument --> SQL statement
                - second argument --> Target once converted
    - SQL statement with a variable
        - ![](img/03031.jpg)
            - third argument --> variable to be inserted into the SQL statement
    - Selecting a column based on `id`
        - ![](img/03032.jpg)
            - second argument --> type of the expected return
            - third argument --> variable to be inserted into SQL statement
    - Mapping through all the roes
        - ![](img/03033.jpg)
            - second argument --> row mapper interface
                - lambda that takes the entire row (`rowset`) and row num (`rowNum`)
                - lamda performs actions on each row
                    - here we create a new `Actor` object with a `first_name` and `last_name`
    - Querying multiple rows
        - ![](img/03034.jpg)
            - note!!! using `.query()` instead of `.queryForObject()`
                - using `.query()` for returning an entire `resultSet`
            - note!!! no third argument
            - note!!! there is a type declaration at the beginning
                - `List<Actor>`
    - Better version -- abstracting the row mapper
        - ![](img/03035.jpg)
- Update
    - perfer not to use `.update` 
        - does not return what is generated
- Spring Boot way
    - ![](img/03036.jpg)

### Creating a Test Database
- From the very start
    - Spring Initializer
        - ![](img/03037.jpg)
    - Dependencies - Spring JPA, H2 Database(JPA driver), 
        - ![](img/03038.jpg)
        - ![](img/03039.jpg)
    - sql files within `src/main/resources/`
        - ![](img/03040.jpg)
    - Schema sql
        - ![](img/03041.jpg)
    - Inserting data sql
        - ![](img/03042.jpg)
    - Note
        - Spring will EXECUTE BOTH ON STARTUP
    - `application.properties` and logging
        - ![](img/03043.jpg)

### Defining the Entities and the Data Access Object (DAO) Interface
- Maven POM
    - starter
        - ![](img/03044.jpg)
    - dependencies
        - ![](img/03045.jpg)
    - plugins
        - ![](img/03046.jpg)
- Creating a DAO
    - data structure of `id` `rank` `firstname` `lastName` 
        - ![](img/03047.jpg)
    - `rank` enum
        -  ![](img/03048.jpg)
    - three constructors
        - ![](img/03049.jpg)
            - empty to handle if NO PARAMETERS are included
            - object WITHOUT `id` makes it easier for creating NEW classes
            - object WITH `id` makes it easier for retrieving FROM DATABASE
            - 
    - getters/setters
        - 
    - making an interface
        - ![](img/03050.jpg)
            - `save()` takes an Officer and returns an Officer
                - the difference; the returned Officer will have an `id` or primary key
            - `findById()` takes an `id` and returns an OPTIONAL
                - why OPTIONAL????  
                    - just in case the returnee doesn't have an Officer
            - `findAll()` returns all Officer
            - `count()` return the number of rows
            - `existsById()` takes an `id` and returns a `boolean`

### Implementing the DAO Layer
- Writing methods for each DAO method
    - Be sure class implements the interface
        - ![](img/03051.jpg)
    - Implement the JdbcTemplate
        - ![](img/03052.jpg)
    - NOTE! in order to implement the wiring of the `JdbcTemplate`... need to be a Spring Managed bean
        - ![](img/03053.jpg)
        - ![](img/03054.jpg)
            - `@Repository` makes it a Spring repository
- `SimpleJdbcInsert`
    - insert `JdbcTemplate`
        - ![](img/03065.jpg)
            - takes in `jdbcTemplate` and generates primary key
            - returns the primary key
    - tell it what table and what column needs the generated primary key
        - ![](img/03067.jpg)
    - abstract the `SimpleJdbcInsert` as `insertOfficer` for the entire program
        - ![](img/03066.jpg)
- Writing each method 
    - count()
        - ![](img/03056.jpg)
    - delete()
        - ![](img/03057.jpg)
    - `existsById()`
        - ![](img/03058.jpg)
    - `findById()`
        - ![](img/03059.jpg)
            - we MUST return ONLY ONE ROW.... so...
                - ![](img/03061.jpg)
            - Notice we need three arguments
                - ![](img/03062.jpg)
        - Simplified version
            - abstracted `officerMapper`
                - ![](img/03063.jpg)
            - implement abstract
                - ![](img/03064.jpg)
    - `save()`
        - ![](img/03068.jpg)
            - call the prior made `SimpleJdbcTemplate` and run the `.executeAndReturnKey()`

### Testing the DAO Layer
- Hamcrest
    - framework that assists writing software tests in the Java programming language
        - supports customized assertion matchers
        - allowing match rules to be defined declaratively
- Spring Framework
    - has a host of all sorts of tests
        - assertJ
        - Mockito
- `@SpringBootTest`
    - sets up JUnit test
        - ![](img/03074.jpg)
    - benefits - singleton application context
        - does not restart
        - maintains a single app context
- Steps
    - Utilize `@SpringBootTest`
        - ![](img/03069.jpg)
    - Autowire your DAO model
        - ![](img/03070.jpg)
    - testing `save()`
        - ![](img/03071.jpg)
    - testing `findById()` for an id we know is IN database
        - ![](img/03072.jpg)
    - testing `findById()` for an id we know is NOT IN database
        - ![](img/03073.jpg)
    - testing `count()` to check for five items in database
        - ![](img/03075.jpg)
    - testing `findAll()`
        - ![](img/03076.jpg)
            - note we are using `containsInAnyOrder()` from Hamcrest
    - testing `delete()`
        - ![](img/03077.jpg)
            - note we check if it exists PRIOR to deleting
            - note we check if database is empty by end
                - make sure to use LAST
    - testings if entries are in the table
        - ![](img/03078.jpg)
            - note the `rangeClosed` and `.forEach()`
- Importance of `@Transactional`
    - Before
        - ![](img/03079.jpg)
            - not all pass
    - After
        - ![](img/03080.jpg)
            - `@Transactional` forces a roll back AFTER EACH TEST
            - ![](img/03081.jpg)

### The Java Persistence API (JPA) and Hibernate
- Mapping to a Database Table using Hibernate
    - java class just for mappling class to database table
        - declare `@Entity`
            - ![](img/03082.jpg)
        - correct for the name of the actual database table with `@Table`
            - ![](img/03083.jpg)
        - remember that there must be a primary key
            - identify primary key with `@Id` and self generate it with `@GeneratedValue`
                - ![](img/03084.jpg)
                    - ![](img/03085.jpg)
        - take note of any `Enum`'s within the database
            - ![](img/03086.jpg)
                - the default enum type is `Ordinal` ... or the position within like
                    - need to declare it as a string
    - Working on the DAO
        - auto wire for Jbdc database with `@Repository`
            - ![](img/03093.jpg)
        - create the Jpa entity manager and invoke `@PersistenceContext`
            - ![](img/03094.jpg)
                - you avoid creating a `entityManager` factory because of Singleton preference
        - working on each method
            - `save()` with Jpa `.persist()`
                - ![](img/03092.jpg)
            - `findById()` with Jpa `.find()`
                - ![](img/03091.jpg)
            - `findAll()` with Jpa `.createQuery()`
                - ![](img/03089.jpg)
            - `count()` with Jpa `.createQuery()`
                - ![](img/03088.jpg)
            - `delete()` with Jpa `.remove()`
                - ![](img/03087.jpg)
            - `existsById()` with Jpa `.createQuery()`
                - ![](img/03090.jpg)

### Testing the JPA DAO Implementation
- Steps
    - Make sure entire test case is running `@SpringBootTest` and `@Transactional`
        - ![](img/03095.jpg)
            - SBT brings in testing dependencies
            - T ensures each test is done in isolation
    - Wire in your `dao` model
        - ![](img/03096.jpg)
    - Wire in your JdbcTemplate 
        - ![](img/03097.jpg)
            - to run SQL queries
    - need to critical methods that will be reused throughout... `getIds`
        - Be prepare to use row mapper / lambdas
            - `getIds` should run a query with a row mapper
                - ![](img/03098.jpg)
    - test each critical database method
        - testing `.save`
            - ![](img/03099.jpg)
        - 
            - ![](img/03100.jpg)
        - 
            - ![](img/03101.jpg)
        - 
            - ![](img/03102.jpg)
        - 
            - ![](img/03103.jpg)
        - testing
            - use Java's `.forEach()` to run `.existsById()` on each record
                - ![](img/03104.jpg)
    - Learning to use Hibernate
        - test failure
            - ![](img/03105.jpg)
                - Hibernate wants to generate database schema from your domain model
                - Hibernate looks at entity and recreates schema
                    - unless told otherwise... Hibernate will OVERWRITE all test
        - fixing Hibernate's default schema (`application.properties`)
            - ![](img/03106.jpg)
            - ![](img/03107.jpg)
            - `create-drop` is default; needs to be changed to none
                - ![](img/03109.jpg)
        - telling Hibernate to use SQL
            - ![](img/03108.jpg)
- Transaction behavior
    - Hibernate wants every access to be in a transaction

### Transactions in Spring
- 
    - 
        - 
    - 
        - 
- 
    - 
        - 
    - 
        - 

### The Spring Data JPA Project
- 
    - 
        - 
    - 
        - 
- 
    - 
        - 
    - 
        - 

### Putting It All Together
- 
    - 
        - 
    - 
        - 
- 
    - 
        - 
    - 
        - 

### Module 3 Summary
- 
    - 
        - 
    - 
        - 
- 
    - 
        - 
    - 
        - 

