<!-- Start Document Outline -->

* [Spring Boot Fundamentals - O'Reilly](#spring-boot-fundamentals---oreilly)
	* [Module 1: A Simple Spring Model-View-Controller (MVC) Application](#module-1-a-simple-spring-model-view-controller-mvc-application)
	* [Module 2: Using Spring to Access REST Services](#module-2-using-spring-to-access-rest-services)
	* [Module 3: Persistence Mechanisms](#module-3-persistence-mechanisms)

<!-- End Document Outline -->

# Spring Boot Fundamentals - O'Reilly



## Module 1: A Simple Spring Model-View-Controller (MVC) Application
### Course Introduction
- Spring
    - built on top of JDK
    - will compare template vs restful service
    - testing + functional testing

### The Role of Spring in Application Development
- Java EE
    - infrastructure that provided services on demand
    - To provide services....
        - had to utilize enterprise javabeans  
        - had to sport servers
            - both not efficient
- Spring
    - 
    - Open source
        - shared services like
            - transactions
            - services
            - resource pooling
    - declarative services
        - provided by `beans`
        - consist of services like...
            - auto wiring
            - dependency injection
    - lifecycle management
        - classes are generated by spring
            - maintained IN MEMORY
            - provide references
                - ... aka... dependency injections
    - ![](img/01002.jpg)
        - beans
            - POJO - plain old Java object
            - Java class with getters and setters
        - difference between Java EE and Spriing
            - declarative
                - similar services
                - ... but.... 
                    - do NOT need to acquire an instance and call it
                        - called programmatic service
                - instead of programmatic service...
                    - no instance... drop an annotation
                    - `@tran`saction` near your method 
    - ![](img/01001.jpg)
    - ![](img/01003.jpg)
        - to perform declarative functions...
            - must provide metadata
                - users change it with `JavaConfig` beans
                    - a way for users to define beans that Spring should be managing within application context
                - users can modify components with `Annotation` beans
                    - RESTcontrollers, repositories
    - ![](img/01004.jpg)
        - execution context where Spring loads beans
            - access the beans through `ApplicationContext`
    - ![](img/01005.jpg)
        - Purpose
            - create an easier way to create beans
            - easier auto configure a new Spring
        - Implementation
            - requires either maven or gradle
            - configure by filling out forms
            - auto-builds an initial web app with desired database drivers
        - easier configuration
            - take a class
            - serialize into json
            - spring boot will automatically get class to JSON 
    - ![](img/01006.jpg)
        - IDE / spring tools suite / VScode

### Creating a New Application
- ![](img/01007.jpg)
    - IMPORTANT -- Spring Boot Version
        - dictates what all dependencies look like
            - ie... correct Hibernate and JBDC versions
    - Java 11 - LTS for now
        - WAR packaging for serving webpages
        - JAR contains Tomcat for more flexibility with 
- ![](img/01008.jpg)
    - Dependencies - Spring Web
        - ThymeLeaf for templating
- ![](img/01009.jpg)
    - Generate compiles dependencies into a `demo.zip`
        - ![](img/01010.jpg)

### Importing into an Integrated Development Environment (IDE)
- ![](img/01011.jpg)
- ![](img/01012.jpg)
- SpringToolSuite
    - Getting the jar within
        - ![](img/01013.jpg)
        - ![](img/01014.jpg)
        - ![](img/01015.jpg)
    - Creating from scratch
        - ![](img/01016.jpg)
        - ![](img/01017.jpg)

### Adding a Controller
- Purpose
    - REST controller receives a request
        - returns a destination
- Creating a Controller
    - Create a class at File Location --- sec/main/java/nameOfApplication
        - ![](img/01018.jpg)
    -  Name the new class
        - ![](img/01019.jpg)
            - ![](img/01020.jpg)
    - Turn the class into a controller with `@Controller`
        - ![](img/01021.jpg)
            - ![](img/01022.jpg)
    - Highlight the annotation to ascertain what is injected
        - ![](img/01023.jpg)
            - Notice it is a `@Component`
    - Note that `@SpringBootApplication` within the main java is a `@ComponentScan`
        - ![](img/01024.jpg)
            - 
    - Creating a controller
        - `@GetMapping` to associate a class with a specific route
            - ![](img/01025.jpg)
        - create a public class that takes a `String` and a view model (`Model`)
            - ![](img/01044.jpg)
                - note the types
                    - `name` parameter is a `String` types
                    - `model` output is a template model types
        - modify the String parameter with `@RequestParam` to dictate required parameter `/hello?name=Mike`
            - ![](img/01026.jpg)
                - `value` dictates name of the parameter
                - `required` dictates requirement
                - `defaultValue` shows what the default value will be for parameter
        - `return` a template from the `src/main/resources/templates`
            - ![](img/01027.jpg)
        - add `name` to the view model with `model.addAttribute()`
            - ![](img/01028.jpg)
                - the viewmodel is `src/main/resources/templates/hello.html`
                    - ![](img/01029.jpg)

### Adding a View
- Implementing a view
    - Utilize ThymeLeaf with html
        - ![](img/01030.jpg)
- Running it 
    - ![](img/01032.jpg)
    - ![](img/01031.jpg)
    - ![](img/01033.jpg)
        - 
- Configuring Java with `application.properties`
    - modifying logging with `logging.level.web=debug`
        - ![](img/01035.jpg)
        - ![](img/01034.jpg)
        - ![](img/01036.jpg)

### Add an Index Page
- Add an index page (`index.html`)
    - ![](img/01037.jpg)
        - ![](img/01038.jpg)
    - ![](img/01039.jpg)
        - ![](img/01040.jpg)
- Outputting a Maven package
    - ![](img/01041.jpg)
        - ![](img/01042.jpg)
- Deploying the maven package
    - ![](img/01043.jpg)

### Testing Controllers Part I
- Writing a JUnit test to invoke Controller class
    - ![](img/01045.jpg)
        - JUnit turns `sayHello` into a `@Test`
        - `HelloController` is instantiated with `new HelloController()`
        - utilize view-model by `BindingAwareModelMap()`
            - Remember that `.sayHello` takes both a string and model
                - need to create the model
                    - ![](img/01046.jpg)
        - utilize `assertAll` JUnit method to invoke all methods
- Note
    - Mockito
        - mocks the interface to properly test all inputs

### Testing Controllers Part II
- Documentation Pattern
    - Read the `Spring` doc
        - Check if it is simplified within `Spring Boot`
- Reading Documentation for Mocking Websites
    - Looking for "mock" on the spring framework documentation
        - ![](img/01047.jpg)
    - Spring Documentation
        - ![](img/01048.jpg)
    - Spring Boot Documentation
        - ![](img/01049.jpg)
            - note that it 
                - auto-configures theMVC
                - looks for `@Controller` and NOT the `@Component`
            - example from the documentation
                - ![](img/01050.jpg)
- Implementation 
    - ![](img/01051.jpg)
        - `@WebMvcTest()` looks for the `HelloController.class` for the test
        - `@Autowired` tells Spring to check for `MockMvc` within `ApplicationContext`
            - to test if it worked
                - ![](img/01052.jpg)
- Actual Test
    - ![](img/01053.jpg)
        - Call the MockMvc instance with `mvc` and run the `.perform(get("/hello"))`
            - ensure the received is a HTML with `.accept(MediaType.TEXT_HTML)`
        - have mockMvc check the `status`, `view`, `model` with `.andExpect()`
        - in the second test... we insert a parameter with `mvc.paran("name","Dolly")`
    - Notice that `MockMvcRequesBuilders` handles all the REST verbs
        - ![](img/01054.jpg)
    - Run the test
        - ![](img/01055.jpg)
        - ![](img/01056.jpg)

### Creating a RESTful Web Service
- Modern day application
    - Generate JSON for device
    - Device receives JSON
- Serializing a Greeting into JSON
    - Greeting class
        - ![](img/01057.jpg)
    - `@RestController`
        - ![](img/01058.jpg)
    - create a `@RestController` class method of `greet`
        - ![](img/01059.jpg)
    - add mapping with `@GetMapping()`
        - ![](img/01060.jpg)
    - add request parameters with `@RequestParam`
        - ![](img/01061.jpg)
- Testing
    - ![](img/01062.jpg)
    - ![](img/01063.jpg)

### Testing RESTful Components
- Will be using `TestRestTemplate`
    - ![](img/01064.jpg)
        - 
- Running a test on REST Controller `HelloRestControllerFunctionalTest`
    - Utilize a `@SpringBootTest` to create a test server with random port number
        - ![](img/01065.jpg)
    - Run two `@Test`, be sure to `@Autowired` the TestRestTemplate
        - ![](img/01066.jpg)
    - utilize the `TestRestTemplate` to turn `Greeting` into a JSON
        - ![](img/01067.jpg)
    - the `.getForEntity` adds more data into the JSON... ie headers and status code, content type
        - ![](img/01069.jpg)
            - ![](img/01068.jpg)
            - notice we get the header, status code and content type
            - notice it is no longer a `response`... but a `ResponseEntity`

### Module 1 Summary
- 
    - 
        - 
    - 
        - 
- 
    - 
        - 
    - 
        - 



## Module 2: Using Spring to Access REST Services
### Module 2 Introduction
- 
    - 
        - 
    - 
        - 
- 
    - 
        - 
    - 
        - 

### The Spring Application Context
- 
    - 
        - 
    - 
        - 
- 
    - 
        - 
    - 
        - 

### Adding Beans Using JavaConfig
- 
    - 
        - 
    - 
        - 
- 
    - 
        - 
    - 
        - 

### Spring's RestTemplate Class
- 
    - 
        - 
    - 
        - 
- 
    - 
        - 
    - 
        - 

### Using the Reactive WebClient Class
- 
    - 
        - 
    - 
        - 
- 
    - 
        - 
    - 
        - 

### Accessing the Google Geocoder
- 
    - 
        - 
    - 
        - 
- 
    - 
        - 
    - 
        - 

### Module 2 Summary
- 
    - 
        - 
    - 
        - 
- 
    - 
        - 
    - 
        - 



## Module 3: Persistence Mechanisms
### Module 3 Introduction
- 
    - 
        - 
    - 
        - 
- 
    - 
        - 
    - 
        - 

### The JdbcTemplate Class
- 
    - 
        - 
    - 
        - 
- 
    - 
        - 
    - 
        - 

### Creating a Test Database
- 
    - 
        - 
    - 
        - 
- 
    - 
        - 
    - 
        - 

### Defining the Entities and the Data Access Object (DAO) Interface
- 
    - 
        - 
    - 
        - 
- 
    - 
        - 
    - 
        - 

### Implementing the DAO Layer
- 
    - 
        - 
    - 
        - 
- 
    - 
        - 
    - 
        - 

### Testing the DAO Layer
- 
    - 
        - 
    - 
        - 
- 
    - 
        - 
    - 
        - 

### The Java Persistence API (JPA) and Hibernate
- 
    - 
        - 
    - 
        - 
- 
    - 
        - 
    - 
        - 

### Testing the JPA DAO Implementation
- 
    - 
        - 
    - 
        - 
- 
    - 
        - 
    - 
        - 

### Transactions in Spring
- 
    - 
        - 
    - 
        - 
- 
    - 
        - 
    - 
        - 

### The Spring Data JPA Project
- 
    - 
        - 
    - 
        - 
- 
    - 
        - 
    - 
        - 

### Putting It All Together
- 
    - 
        - 
    - 
        - 
- 
    - 
        - 
    - 
        - 

### Module 3 Summary
- 
    - 
        - 
    - 
        - 
- 
    - 
        - 
    - 
        - 

