<!-- Start Document Outline -->

* [Spring Boot Fundamentals - O'Reilly](#spring-boot-fundamentals---oreilly)
	* [Module 1: A Simple Spring Model-View-Controller (MVC) Application](#module-1-a-simple-spring-model-view-controller-mvc-application)
	* [Module 2: Using Spring to Access REST Services](#module-2-using-spring-to-access-rest-services)
	* [Module 3: Persistence Mechanisms](#module-3-persistence-mechanisms)

<!-- End Document Outline -->

# Spring Boot Fundamentals - O'Reilly



## Module 1: A Simple Spring Model-View-Controller (MVC) Application
### Course Introduction
- Spring
    - built on top of JDK
    - will compare template vs restful service
    - testing + functional testing

### The Role of Spring in Application Development
- Java EE
    - infrastructure that provided services on demand
    - To provide services....
        - had to utilize enterprise javabeans  
        - had to sport servers
            - both not efficient
- Spring
    - 
    - Open source
        - shared services like
            - transactions
            - services
            - resource pooling
    - declarative services
        - provided by `beans`
        - consist of services like...
            - auto wiring
            - dependency injection
    - lifecycle management
        - classes are generated by spring
            - maintained IN MEMORY
            - provide references
                - ... aka... dependency injections
    - ![](img/01002.jpg)
        - beans
            - POJO - plain old Java object
            - Java class with getters and setters
        - difference between Java EE and Spriing
            - declarative
                - similar services
                - ... but.... 
                    - do NOT need to acquire an instance and call it
                        - called programmatic service
                - instead of programmatic service...
                    - no instance... drop an annotation
                    - `@tran`saction` near your method 
    - ![](img/01001.jpg)
    - ![](img/01003.jpg)
        - to perform declarative functions...
            - must provide metadata
                - users change it with `JavaConfig` beans
                    - a way for users to define beans that Spring should be managing within application context
                - users can modify components with `Annotation` beans
                    - RESTcontrollers, repositories
    - ![](img/01004.jpg)
        - execution context where Spring loads beans
            - access the beans through `ApplicationContext`
    - ![](img/01005.jpg)
        - Purpose
            - create an easier way to create beans
            - easier auto configure a new Spring
        - Implementation
            - requires either maven or gradle
            - configure by filling out forms
            - auto-builds an initial web app with desired database drivers
        - easier configuration
            - take a class
            - serialize into json
            - spring boot will automatically get class to JSON 
    - ![](img/01006.jpg)
        - IDE / spring tools suite / VScode

### Creating a New Application
- ![](img/01007.jpg)
    - IMPORTANT -- Spring Boot Version
        - dictates what all dependencies look like
            - ie... correct Hibernate and JBDC versions
    - Java 11 - LTS for now
        - WAR packaging for serving webpages
        - JAR contains Tomcat for more flexibility with 
- ![](img/01008.jpg)
    - Dependencies - Spring Web
        - ThymeLeaf for templating
- ![](img/01009.jpg)
    - Generate compiles dependencies into a `demo.zip`
        - ![](img/01010.jpg)

### Importing into an Integrated Development Environment (IDE)
- ![](img/01011.jpg)
- ![](img/01012.jpg)
- SpringToolSuite
    - Getting the jar within
        - ![](img/01013.jpg)
        - ![](img/01014.jpg)
        - ![](img/01015.jpg)
    - Creating from scratch
        - ![](img/01016.jpg)
        - ![](img/01017.jpg)

### Adding a Controller
- Purpose
    - REST controller receives a request
        - returns a destination
- Creating a Controller
    - Create a class at File Location --- sec/main/java/nameOfApplication
        - ![](img/01018.jpg)
    -  Name the new class
        - ![](img/01019.jpg)
            - ![](img/01020.jpg)
    - Turn the class into a controller with `@Controller`
        - ![](img/01021.jpg)
            - ![](img/01022.jpg)
    - Highlight the annotation to ascertain what is injected
        - ![](img/01023.jpg)
            - Notice it is a `@Component`
    - Note that `@SpringBootApplication` within the main java is a `@ComponentScan`
        - ![](img/01024.jpg)
            - 
    - Creating a controller
        - `@GetMapping` to associate a class with a specific route
            - ![](img/01025.jpg)
        - create a public class that takes a `String` and a view model (`Model`)
            - ![](img/01044.jpg)
                - note the types
                    - `name` parameter is a `String` types
                    - `model` output is a template model types
        - modify the String parameter with `@RequestParam` to dictate required parameter `/hello?name=Mike`
            - ![](img/01026.jpg)
                - `value` dictates name of the parameter
                - `required` dictates requirement
                - `defaultValue` shows what the default value will be for parameter
        - `return` a template from the `src/main/resources/templates`
            - ![](img/01027.jpg)
        - add `name` to the view model with `model.addAttribute()`
            - ![](img/01028.jpg)
                - the viewmodel is `src/main/resources/templates/hello.html`
                    - ![](img/01029.jpg)

### Adding a View
- Implementing a view
    - Utilize ThymeLeaf with html
        - ![](img/01030.jpg)
- Running it 
    - ![](img/01032.jpg)
    - ![](img/01031.jpg)
    - ![](img/01033.jpg)
        - 
- Configuring Java with `application.properties`
    - modifying logging with `logging.level.web=debug`
        - ![](img/01035.jpg)
        - ![](img/01034.jpg)
        - ![](img/01036.jpg)

### Add an Index Page
- Add an index page (`index.html`)
    - ![](img/01037.jpg)
        - ![](img/01038.jpg)
    - ![](img/01039.jpg)
        - ![](img/01040.jpg)
- Outputting a Maven package
    - ![](img/01041.jpg)
        - ![](img/01042.jpg)
- Deploying the maven package
    - ![](img/01043.jpg)

### Testing Controllers Part I
- Writing a JUnit test to invoke Controller class
    - ![](img/01045.jpg)
        - JUnit turns `sayHello` into a `@Test`
        - `HelloController` is instantiated with `new HelloController()`
        - utilize view-model by `BindingAwareModelMap()`
            - Remember that `.sayHello` takes both a string and model
                - need to create the model
                    - ![](img/01046.jpg)
        - utilize `assertAll` JUnit method to invoke all methods
- Note
    - Mockito
        - mocks the interface to properly test all inputs

### Testing Controllers Part II
- Documentation Pattern
    - Read the `Spring` doc
        - Check if it is simplified within `Spring Boot`
- Reading Documentation for Mocking Websites
    - Looking for "mock" on the spring framework documentation
        - ![](img/01047.jpg)
    - Spring Documentation
        - ![](img/01048.jpg)
    - Spring Boot Documentation
        - ![](img/01049.jpg)
            - note that it 
                - auto-configures theMVC
                - looks for `@Controller` and NOT the `@Component`
            - example from the documentation
                - ![](img/01050.jpg)
- Implementation 
    - ![](img/01051.jpg)
        - `@WebMvcTest()` looks for the `HelloController.class` for the test
        - `@Autowired` tells Spring to check for `MockMvc` within `ApplicationContext`
            - to test if it worked
                - ![](img/01052.jpg)
- Actual Test
    - ![](img/01053.jpg)
        - Call the MockMvc instance with `mvc` and run the `.perform(get("/hello"))`
            - ensure the received is a HTML with `.accept(MediaType.TEXT_HTML)`
        - have mockMvc check the `status`, `view`, `model` with `.andExpect()`
        - in the second test... we insert a parameter with `mvc.paran("name","Dolly")`
    - Notice that `MockMvcRequesBuilders` handles all the REST verbs
        - ![](img/01054.jpg)
    - Run the test
        - ![](img/01055.jpg)
        - ![](img/01056.jpg)

### Creating a RESTful Web Service
- Modern day application
    - Generate JSON for device
    - Device receives JSON
- Serializing a Greeting into JSON
    - Greeting class
        - ![](img/01057.jpg)
    - `@RestController`
        - ![](img/01058.jpg)
    - create a `@RestController` class method of `greet`
        - ![](img/01059.jpg)
    - add mapping with `@GetMapping()`
        - ![](img/01060.jpg)
    - add request parameters with `@RequestParam`
        - ![](img/01061.jpg)
- Testing
    - ![](img/01062.jpg)
    - ![](img/01063.jpg)

### Testing RESTful Components
- Will be using `TestRestTemplate`
    - ![](img/01064.jpg)
        - 
- Running a test on REST Controller `HelloRestControllerFunctionalTest`
    - Utilize a `@SpringBootTest` to create a test server with random port number
        - ![](img/01065.jpg)
    - Run two `@Test`, be sure to `@Autowired` the TestRestTemplate
        - ![](img/01066.jpg)
    - utilize the `TestRestTemplate` to turn `Greeting` into a JSON
        - ![](img/01067.jpg)
    - the `.getForEntity` adds more data into the JSON... ie headers and status code, content type
        - ![](img/01069.jpg)
            - ![](img/01068.jpg)
            - notice we get the header, status code and content type
            - notice it is no longer a `response`... but a `ResponseEntity`


## Module 2: Using Spring to Access REST Services
* [Go to Module 3](#module-3-persistence-mechanisms)

### The Spring Application Context
- Application Context
    - auto wire your application context
        - ![](img/02002.jpg)
            - ![](img/02001.jpg)
    - see what is in the application context 
        - ![](img/02004.jpg)
    - see all the beans with `.getBeanDefinitionCount()`
        - ![](img/02005.jpg)
            - ![](img/02006.jpg)
        - ![](img/02007.jpg)
    - If you change the controllers name with `@Controller(newName)`
        - ![](img/02008.jpg)
    - `Greeting.java` is NOT used in any part of the `ApplicationContext`
        - therefore...
            - never loaded
        - if we put it in the test...
            - ![](img/02009.jpg)
        - to force `Greeting.java` to be used...
            - before...
                - ![](img/02010.jpg)
            - after...
                - ![](img/02011.jpg)
- NOTE
    - all objects within `ApplicationContext` are Singletons
        - ![](img/02012.jpg)
            - we thought we created two separate instances of `Greeting.class`
                - instead...
                    - `greeting2` is just a reference to `greeting1`
    - ONLY WAY AROUND THIS... prototype it to be a factory
        - with `@Scope`

### Adding Beans Using JavaConfig
- Avoid `ApplicationContext` manipulation by setting configs with `JavaConfig`
    - 
        - 
- `@SpringBootApplication` has a configuration
    - Taking a look at the docs...
        - ![](img/02013.jpg)
            - ![](img/02014.jpg)
    - Typical `@Configuration` setup
        - ![](img/02015.jpg)
            - annotate methods with an `@Bean` so that it would instantiates/configures that bean
    - Since `@SpringBootApplication` is a `@Configuration`...
        - ![](img/02016.jpg)
    - Testing it...
        - ![](img/02017.jpg)
- Moving the configurations to its own file
    - creating `AppConfig.java`
        - ![](img/02018.jpg)
    - Creating an alternate greeting
        - ![](img/02019.jpg)
            - ![](img/02020.jpg)
    - Fixing the `expected single bean` error
        - ![](img/02021.jpg)
            - ![](img/02022.jpg)

### Spring's RestTemplate Class
- Intro
    - Will run an API through RestTemplate
        - the API source
            - ![](img/02023.jpg)
            - ![](img/02024.jpg)
            - ![](img/02025.jpg)
                - Note the `people: [ { "name": "asdf", "craft":"asdf" }, ...` format
- Writing the API Fetcher
    - Organizing JSON into Java
        - Writing a POJO for the inbound data
            - Setting up the data structure
                - ![](img/02026.jpg)
            - Establishing getters / setters
                - ![](img/02027.jpg)
        - Writing a POJO for the outbound data
            - Data Structure
                - ![](img/02030.jpg)
            - Establishing getters / setters
                - ![](img/02031.jpg)
    - Creating a template
        - templates are created using `RestTemplateBuilder`
            - doc...
                - ![](img/02028.jpg)
            - implementation
                - create a `RestTemplateBuilder` instance; call `.build()` method; insert into `template`
                    - ![](img/02032.jpg)
                - note the different methods that could be invoked
                    - ![](img/02033.jpg)
    - Calling API
        - utilize the `.getForObject()` from the URL; put it into `AstroResult` data structure
            - ![](img/02034.jpg)
    - Create a service bean
        - What is a service
            - ![](img/02029.jpg)
        - Implementation
            - ![](img/02035.jpg)
- Testing the API Fetcher
    - Wire it to the API service bean
        - ![](img/02036.jpg)
    - Call the test method
        - ![](img/02037.jpg)
    - Within test method, call the service and store it
        - ![](img/02038.jpg)
    - Within test method, print out the numbers
        - ![](img/02039.jpg)
            - notice we are utilizing the `.getNumber()` getter
    - Within test method, print out all the people
        - ![](img/02040.jpg)
    - Assert to check the results
        - ![](img/02041.jpg)

### Using the Reactive WebClient Class
- Intro
    - Reactive WebClient
        - the modern version of `RestTemplate`
    - What is it...
        - ![](img/02042.jpg)
            - an error won't stop the `ApplicationContext`
            - an infinite wait won't slow down the application
- `WebClient.ResponseSpec` `retrieve()`
    - the docs...
        - ![](img/02043.jpg)
            - `.get()` acts like a GET html action
            - `.uri("")` dictates route that calls get function
            - `.accept()` dictates the anticipated file format
            - `.retrieve()` executes get action
            - `.bodyToMono()` converts JSON into Java class; name of java class is specified within `()`
    - implementation
        - instantiate a `WebClient`
            - ![](img/02044.jpg)
        - wire the `WebClient.Builder` and build it on the API address
            - ![](img/02045.jpg)
        - run the `retrieve()` library onto the `client`
            - ![](img/02046.jpg)
    - testing
        - mostly the same; ensure to call the proper function
            - ![](img/02047.jpg)

### Accessing the Google Geocoder
- What is Geocoding
    - Google definition
        - ![](img/03001.jpg)
    - Two Required Parameters to be aware
        - ![](img/03002.jpg)
        - ![](img/03003.jpg)
    - Response
        - ![](img/03004.jpg)
            - ![](img/03005.jpg)
                - Note the `lat` `lng`
- Fitting Geocoding into Java
    - Lat / Lng Java Class
        - ![](img/03006.jpg)
    - Geometry Class
        - ![](img/03007.jpg)
    - Result Class (takes Geometry and returns LatLng)
        - ![](img/03008.jpg)
    - Response Class (takes multiple results)
        - ![](img/03009.jpg)
    - Site Class 
        - ![](img/03017.jpg)
- Creating a Geocoder Service
    - Creating a `@Service` bean
        - ![](img/03010.jpg)
    - `@Autowired` the `WebClient.Builder`
        - ![](img/03011.jpg)
    - Create a method to retrieve the geocode json and 
        - `.collect()` the `Stream` of the input `address` in the `encoded`
            - ![](img/03015.jpg)
        - send the `encoded` in a `.retrieve()` request
            - ![](img/03016.jpg)
                - store the results within the `Response` format
    - getting the results we want...
        - to get the addresses...
            - run `Result`'s `getFormattedAddress()` on the response first
                - ![](img/03014.jpg)
        - to get the lat / longd
            - run `Geometry`'s `getLocation()`
                - ![](img/03012.jpg)
            - run `Location`'s `.getLat()` / `.getLng()`
                - ![](img/03013.jpg)
- Testing the service
    - Writing the test
        - the first test (merely name of a city)
            - ![](img/03018.jpg)
        - the second test (actual address)
            - ![](img/03019.jpg)
        - notice we call the logger AFTER EVER `site` call
            - ![](img/03020.jpg)
    - Results
        - HTTP GET request sent
            - ![](img/03021.jpg)
        - Lat / Long3
            - ![](img/03022.jpg)
        - fixing the `address: null`
            - difference in the documentation
                - ![](img/03023.jpg)
                - ![](img/03024.jpg)
            - check the config.... (`application.properties`)
                - ![](img/03025.jpg)
        - getting the results
            - ![](img/03026.jpg)


## Module 3: Persistence Mechanisms
### Module 3 Introduction
- 
    - 
        - 
    - 
        - 
- 
    - 
        - 
    - 
        - 

### The JdbcTemplate Class
- 
    - 
        - 
    - 
        - 
- 
    - 
        - 
    - 
        - 

### Creating a Test Database
- 
    - 
        - 
    - 
        - 
- 
    - 
        - 
    - 
        - 

### Defining the Entities and the Data Access Object (DAO) Interface
- 
    - 
        - 
    - 
        - 
- 
    - 
        - 
    - 
        - 

### Implementing the DAO Layer
- 
    - 
        - 
    - 
        - 
- 
    - 
        - 
    - 
        - 

### Testing the DAO Layer
- 
    - 
        - 
    - 
        - 
- 
    - 
        - 
    - 
        - 

### The Java Persistence API (JPA) and Hibernate
- 
    - 
        - 
    - 
        - 
- 
    - 
        - 
    - 
        - 

### Testing the JPA DAO Implementation
- 
    - 
        - 
    - 
        - 
- 
    - 
        - 
    - 
        - 

### Transactions in Spring
- 
    - 
        - 
    - 
        - 
- 
    - 
        - 
    - 
        - 

### The Spring Data JPA Project
- 
    - 
        - 
    - 
        - 
- 
    - 
        - 
    - 
        - 

### Putting It All Together
- 
    - 
        - 
    - 
        - 
- 
    - 
        - 
    - 
        - 

### Module 3 Summary
- 
    - 
        - 
    - 
        - 
- 
    - 
        - 
    - 
        - 

